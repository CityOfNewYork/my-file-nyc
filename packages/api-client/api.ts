/* tslint:disable */
/* eslint-disable */
/**
 * Data Locker
 * This documents the API for the New America Data Locker project.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An activity item
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {ActivityPrincipal}
     * @memberof Activity
     */
    'principal': ActivityPrincipal;
    /**
     * 
     * @type {ActivityActionTypeEnum}
     * @memberof Activity
     */
    'type': ActivityActionTypeEnum;
    /**
     * The ID of the request that created this action
     * @type {string}
     * @memberof Activity
     */
    'requestId': string;
    /**
     * The date the activity happened
     * @type {string}
     * @memberof Activity
     */
    'date': string;
    /**
     * 
     * @type {ActivityResource}
     * @memberof Activity
     */
    'resource': ActivityResource;
    /**
     * The list of any additional resources part of this activity
     * @type {Array<ActivityResource>}
     * @memberof Activity
     */
    'relatedResources'?: Array<ActivityResource>;
}
/**
 * The type of an activity action
 * @export
 * @enum {string}
 */

export const ActivityActionTypeEnum = {
    CollectionCreated: 'COLLECTION.CREATED',
    DocumentCreated: 'DOCUMENT.CREATED',
    DocumentAccessed: 'DOCUMENT.ACCESSED',
    DocumentEdited: 'DOCUMENT.EDITED',
    DocumentDeleted: 'DOCUMENT.DELETED',
    DelegateduserInvited: 'DELEGATEDUSER.INVITED',
    DelegateduserInviteAccepted: 'DELEGATEDUSER.INVITE_ACCEPTED',
    DelegateduserDeleted: 'DELEGATEDUSER.DELETED',
    UserTermsAccepted: 'USER.TERMS_ACCEPTED'
} as const;

export type ActivityActionTypeEnum = typeof ActivityActionTypeEnum[keyof typeof ActivityActionTypeEnum];


/**
 * A list of account activity
 * @export
 * @interface ActivityList
 */
export interface ActivityList {
    /**
     * The list of account activity
     * @type {Array<Activity>}
     * @memberof ActivityList
     */
    'activity': Array<Activity>;
    /**
     * The token to use to fetch further account activity
     * @type {string}
     * @memberof ActivityList
     */
    'nextToken': string | null;
}
/**
 * Details on the user principal that performed the activity
 * @export
 * @interface ActivityPrincipal
 */
export interface ActivityPrincipal {
    /**
     * The ID of the principal
     * @type {string}
     * @memberof ActivityPrincipal
     */
    'id': string;
    /**
     * The consistent name of the principal, generally the user email, for human readable reference.
     * @type {string}
     * @memberof ActivityPrincipal
     */
    'name': string;
}
/**
 * A resource (or record) related to an activity
 * @export
 * @interface ActivityResource
 */
export interface ActivityResource {
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActivityResource
     */
    'id': string;
    /**
     * The name of the resource, at the time of the activity, for human readable reference.
     * @type {string}
     * @memberof ActivityResource
     */
    'name': string;
    /**
     * 
     * @type {ActivityResourceTypeEnum}
     * @memberof ActivityResource
     */
    'type': ActivityResourceTypeEnum;
    /**
     * The list of any changes made to the resource
     * @type {Array<ActivityResourceChange>}
     * @memberof ActivityResource
     */
    'changes'?: Array<ActivityResourceChange>;
}
/**
 * Changes made to a resource
 * @export
 * @interface ActivityResourceChange
 */
export interface ActivityResourceChange {
    /**
     * The name of the field that was change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    'field': string;
    /**
     * The value of the field before the change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    'oldValue': string | null;
    /**
     * The value of the field after the change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    'newValue': string | null;
}
/**
 * The type of an activity resource
 * @export
 * @enum {string}
 */

export const ActivityResourceTypeEnum = {
    Collection: 'COLLECTION',
    CollectionIndividualEmailGrant: 'COLLECTION.INDIVIDUAL_EMAIL_GRANT',
    Document: 'DOCUMENT',
    DocumentFile: 'DOCUMENT.FILE',
    Delegateduser: 'DELEGATEDUSER',
    User: 'USER'
} as const;

export type ActivityResourceTypeEnum = typeof ActivityResourceTypeEnum[keyof typeof ActivityResourceTypeEnum];


/**
 * A collection of documents
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * The ID of the collection
     * @type {string}
     * @memberof Collection
     */
    'id': string;
    /**
     * The name of the collection
     * @type {string}
     * @memberof Collection
     */
    'name': string;
    /**
     * Status of the collection
     * @type {string}
     * @memberof Collection
     */
    'status': string;
    /**
     * The date the collection was created
     * @type {string}
     * @memberof Collection
     */
    'createdDate': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof Collection
     */
    'links': Array<Link>;
    /**
     * The number of documents contained in the collection.
     * @type {number}
     * @memberof Collection
     */
    'numberOfDocuments'?: number;
}
/**
 * Request data to create a collection
 * @export
 * @interface CollectionCreate
 */
export interface CollectionCreate {
    /**
     * The name of the collection
     * @type {string}
     * @memberof CollectionCreate
     */
    'name': string;
    /**
     * The ID\'s of the Documents to add to this collection
     * @type {Array<string>}
     * @memberof CollectionCreate
     */
    'documentIds': Array<string>;
    /**
     * The email addresses of individuals to grant access to this collection
     * @type {Array<string>}
     * @memberof CollectionCreate
     */
    'individualEmailAddresses': Array<string>;
}
/**
 * A collection access grant
 * @export
 * @interface CollectionGrant
 */
export interface CollectionGrant {
    /**
     * The ID of the grant
     * @type {string}
     * @memberof CollectionGrant
     */
    'id': string;
    /**
     * 
     * @type {CollectionGrantType}
     * @memberof CollectionGrant
     */
    'type': CollectionGrantType;
    /**
     * The date the grant was created
     * @type {string}
     * @memberof CollectionGrant
     */
    'createdDate': string;
    /**
     * The email address that has been granted access
     * @type {string}
     * @memberof CollectionGrant
     */
    'individualEmailAddress': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof CollectionGrant
     */
    'links': Array<Link>;
}
/**
 * A result containing a list of access grants to a document
 * @export
 * @interface CollectionGrantList
 */
export interface CollectionGrantList {
    /**
     * The list of grants for a collection
     * @type {Array<CollectionGrant>}
     * @memberof CollectionGrantList
     */
    'collectionGrants': Array<CollectionGrant>;
}
/**
 * The valid types for access grants to a collection
 * @export
 * @enum {string}
 */

export const CollectionGrantType = {
    IndividualEmail: 'INDIVIDUAL_EMAIL'
} as const;

export type CollectionGrantType = typeof CollectionGrantType[keyof typeof CollectionGrantType];


/**
 * A result containing a list of collections
 * @export
 * @interface CollectionList
 */
export interface CollectionList {
    /**
     * The collections list
     * @type {Array<CollectionListItem>}
     * @memberof CollectionList
     */
    'collections': Array<CollectionListItem>;
}
/**
 * Basic details for listing a collection
 * @export
 * @interface CollectionListItem
 */
export interface CollectionListItem {
    /**
     * The ID of the collection
     * @type {string}
     * @memberof CollectionListItem
     */
    'id': string;
    /**
     * The name of the collection
     * @type {string}
     * @memberof CollectionListItem
     */
    'name': string;
    /**
     * Status of the collection
     * @type {string}
     * @memberof CollectionListItem
     */
    'status': string;
    /**
     * The date the collection was created
     * @type {string}
     * @memberof CollectionListItem
     */
    'createdDate': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof CollectionListItem
     */
    'links': Array<Link>;
    /**
     * The number of documents contained in the collection.
     * @type {number}
     * @memberof CollectionListItem
     */
    'numberOfDocuments'?: number;
}
/**
 * Request data to create a collection
 * @export
 * @interface CollectionStatusPatch
 */
export interface CollectionStatusPatch {
    /**
     * Status/state of the collection
     * @type {string}
     * @memberof CollectionStatusPatch
     */
    'status': CollectionStatusPatchStatusEnum;
}

export const CollectionStatusPatchStatusEnum = {
    Pending: 'pending',
    Complete: 'complete'
} as const;

export type CollectionStatusPatchStatusEnum = typeof CollectionStatusPatchStatusEnum[keyof typeof CollectionStatusPatchStatusEnum];

/**
 * A document
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * The ID of the document
     * @type {string}
     * @memberof Document
     */
    'id': string;
    /**
     * Document name (system or user provided)
     * @type {string}
     * @memberof Document
     */
    'name': string;
    /**
     * Document status
     * @type {string}
     * @memberof Document
     */
    'status': string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof Document
     */
    'description': string | null;
    /**
     * AV status of the files
     * @type {string}
     * @memberof Document
     */
    'scanStatus': string;
    /**
     * Date the document was created
     * @type {string}
     * @memberof Document
     */
    'createdDate': string;
    /**
     * The files in the document
     * @type {Array<DocumentFile>}
     * @memberof Document
     */
    'files': Array<DocumentFile>;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof Document
     */
    'links': Array<Link>;
    /**
     * Signifies whether or not this document was assembled as a pdf of multiple uploaded files.
     * @type {boolean}
     * @memberof Document
     */
    'isMultipageDocument'?: boolean;
    /**
     * The presigned url for downloading the assembled pdf document.
     * @type {string}
     * @memberof Document
     */
    'pdf'?: string;
    /**
     * The presigned url for downloading the assembled pdf document\'s thumbnail.
     * @type {string}
     * @memberof Document
     */
    'pdfThumbnail'?: string;
}
/**
 * Request data to create a document
 * @export
 * @interface DocumentCreate
 */
export interface DocumentCreate {
    /**
     * Document name (system or user provided)
     * @type {string}
     * @memberof DocumentCreate
     */
    'name': string;
    /**
     * Document status
     * @type {string}
     * @memberof DocumentCreate
     */
    'status'?: string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof DocumentCreate
     */
    'description'?: string;
    /**
     * The files that are part of the document
     * @type {Array<DocumentCreateFile>}
     * @memberof DocumentCreate
     */
    'files': Array<DocumentCreateFile>;
    /**
     * Specify if the document to be created is a multi-page document
     * @type {boolean}
     * @memberof DocumentCreate
     */
    'isMultipageDocument'?: boolean;
}
/**
 * Request data to create a file of a document
 * @export
 * @interface DocumentCreateFile
 */
export interface DocumentCreateFile {
    /**
     * File original name
     * @type {string}
     * @memberof DocumentCreateFile
     */
    'name': string;
    /**
     * 
     * @type {FileContentTypeEnum}
     * @memberof DocumentCreateFile
     */
    'contentType': FileContentTypeEnum;
    /**
     * SHA256 Checksum of file content
     * @type {string}
     * @memberof DocumentCreateFile
     */
    'sha256Checksum': string;
    /**
     * Content length in bytes of the file
     * @type {number}
     * @memberof DocumentCreateFile
     */
    'contentLength': number;
}
/**
 * A file of a document
 * @export
 * @interface DocumentFile
 */
export interface DocumentFile {
    /**
     * The ID of the document file
     * @type {string}
     * @memberof DocumentFile
     */
    'id': string;
    /**
     * File original name
     * @type {string}
     * @memberof DocumentFile
     */
    'name': string;
    /**
     * 
     * @type {FileContentTypeEnum}
     * @memberof DocumentFile
     */
    'contentType': FileContentTypeEnum;
    /**
     * SHA256 Checksum of file content
     * @type {string}
     * @memberof DocumentFile
     */
    'sha256Checksum': string;
    /**
     * Content length in bytes of the file
     * @type {number}
     * @memberof DocumentFile
     */
    'contentLength': number;
    /**
     * Date the document file was created
     * @type {string}
     * @memberof DocumentFile
     */
    'createdDate': string;
    /**
     * AV status of the files
     * @type {string}
     * @memberof DocumentFile
     */
    'scanStatus': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof DocumentFile
     */
    'links': Array<Link>;
    /**
     * Signifies whether or not this document was assembled as a pdf of multiple uploaded files.
     * @type {boolean}
     * @memberof DocumentFile
     */
    'isMultipageDocument'?: boolean;
    /**
     * The presigned url for downloading the assembled pdf document.
     * @type {string}
     * @memberof DocumentFile
     */
    'pdf'?: string;
    /**
     * The presigned url for downloading the assembled pdf document\'s thumbnail.
     * @type {string}
     * @memberof DocumentFile
     */
    'pdfThumbnail'?: string;
}
/**
 * A result containing a list of documents
 * @export
 * @interface DocumentList
 */
export interface DocumentList {
    /**
     * The documents list
     * @type {Array<DocumentListItem>}
     * @memberof DocumentList
     */
    'documents': Array<DocumentListItem>;
}
/**
 * A listed document, deliberately minimal
 * @export
 * @interface DocumentListItem
 */
export interface DocumentListItem {
    /**
     * The ID of the document
     * @type {string}
     * @memberof DocumentListItem
     */
    'id': string;
    /**
     * The human readable name of the document
     * @type {string}
     * @memberof DocumentListItem
     */
    'name': string;
    /**
     * Document status
     * @type {string}
     * @memberof DocumentListItem
     */
    'status': string;
    /**
     * Date the document was created
     * @type {string}
     * @memberof DocumentListItem
     */
    'createdDate': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof DocumentListItem
     */
    'links': Array<Link>;
}
/**
 * Request data to update a document
 * @export
 * @interface DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * Document name.
     * @type {string}
     * @memberof DocumentUpdate
     */
    'name'?: string;
    /**
     * Document status
     * @type {string}
     * @memberof DocumentUpdate
     */
    'status'?: string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof DocumentUpdate
     */
    'description'?: string | null;
}
/**
 * Details about a document download
 * @export
 * @interface DocumentsDownload
 */
export interface DocumentsDownload {
    /**
     * The ID of the download
     * @type {string}
     * @memberof DocumentsDownload
     */
    'id': string;
    /**
     * 
     * @type {DocumentsDownloadStatusEnum}
     * @memberof DocumentsDownload
     */
    'status': DocumentsDownloadStatusEnum;
    /**
     * 
     * @type {FileDownload}
     * @memberof DocumentsDownload
     */
    'fileDownload': FileDownload | null;
}
/**
 * Request data to create a download of a set of documents
 * @export
 * @interface DocumentsDownloadCreate
 */
export interface DocumentsDownloadCreate {
    /**
     * 
     * @type {DocumentsDownloadFormatEnum}
     * @memberof DocumentsDownloadCreate
     */
    'format': DocumentsDownloadFormatEnum;
}
/**
 * The valid formats for a requested download
 * @export
 * @enum {string}
 */

export const DocumentsDownloadFormatEnum = {
    Zip: 'ZIP'
} as const;

export type DocumentsDownloadFormatEnum = typeof DocumentsDownloadFormatEnum[keyof typeof DocumentsDownloadFormatEnum];


/**
 * The valid statuses for a requested download
 * @export
 * @enum {string}
 */

export const DocumentsDownloadStatusEnum = {
    Success: 'SUCCESS',
    Pending: 'PENDING'
} as const;

export type DocumentsDownloadStatusEnum = typeof DocumentsDownloadStatusEnum[keyof typeof DocumentsDownloadStatusEnum];


/**
 * The accepted content type for files
 * @export
 * @enum {string}
 */

export const FileContentTypeEnum = {
    ApplicationPdf: 'application/pdf',
    ImageJpeg: 'image/jpeg',
    ImagePng: 'image/png',
    ImageTiff: 'image/tiff'
} as const;

export type FileContentTypeEnum = typeof FileContentTypeEnum[keyof typeof FileContentTypeEnum];


/**
 * A result containing a download link to a file
 * @export
 * @interface FileDownload
 */
export interface FileDownload {
    /**
     * The web address (relative or absolute) for the linked resource
     * @type {string}
     * @memberof FileDownload
     */
    'href': string;
}
/**
 * The disposition type for the file download
 * @export
 * @enum {string}
 */

export const FileDownloadDispositionTypeEnum = {
    Inline: 'inline',
    Attachment: 'attachment'
} as const;

export type FileDownloadDispositionTypeEnum = typeof FileDownloadDispositionTypeEnum[keyof typeof FileDownloadDispositionTypeEnum];


/**
 * A HATEOS Link
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * The web address (relative or absolute) for the linked resource
     * @type {string}
     * @memberof Link
     */
    'href': string;
    /**
     * The relation this linked resource has to the resource it is attached to.
     * @type {string}
     * @memberof Link
     */
    'rel': string;
    /**
     * The HTTP method to use to access the linked resource
     * @type {string}
     * @memberof Link
     */
    'type': string;
    /**
     * Form data to include in the request
     * @type {{ [key: string]: string; }}
     * @memberof Link
     */
    'includeFormData'?: { [key: string]: string; };
}
/**
 * A record owner
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The user id
     * @type {string}
     * @memberof Owner
     */
    'id': string;
    /**
     * The users given name
     * @type {string}
     * @memberof Owner
     */
    'givenName': string | null;
    /**
     * The users family name
     * @type {string}
     * @memberof Owner
     */
    'familyName': string | null;
    /**
     * The users name or email address, if name not provided
     * @type {string}
     * @memberof Owner
     */
    'name': string;
    /**
     * Date of birth in format \'mm/dd/yyyy\'
     * @type {string}
     * @memberof Owner
     */
    'dob': string;
    /**
     * The issued DHS Case Number for this user
     * @type {string}
     * @memberof Owner
     */
    'dhsCaseNumber': string;
    /**
     * Locale for the user
     * @type {string}
     * @memberof Owner
     */
    'locale': string;
}
/**
 * Edit user data
 * @export
 * @interface PatchUserData
 */
export interface PatchUserData {
    /**
     * A person\'s last name
     * @type {string}
     * @memberof PatchUserData
     */
    'familyName': string;
    /**
     * A person\'s first name
     * @type {string}
     * @memberof PatchUserData
     */
    'givenName': string;
    /**
     * Date of birth in format \'mm/dd/yyyy\'
     * @type {string}
     * @memberof PatchUserData
     */
    'dob': string;
    /**
     * The issued DHS Case Number for this user
     * @type {string}
     * @memberof PatchUserData
     */
    'dhsCaseNumber': string;
    /**
     * Locale of the user used for i18n
     * @type {string}
     * @memberof PatchUserData
     */
    'locale': string;
}
/**
 * User registration information
 * @export
 * @interface RegistrationDetails
 */
export interface RegistrationDetails {
    /**
     * A person\'s last name
     * @type {string}
     * @memberof RegistrationDetails
     */
    'familyName': string;
    /**
     * A person\'s first name
     * @type {string}
     * @memberof RegistrationDetails
     */
    'givenName': string;
    /**
     * Date of birth in format \'mm/dd/yyyy\'
     * @type {string}
     * @memberof RegistrationDetails
     */
    'dob': string;
    /**
     * The issued DHS Case Number for this user
     * @type {string}
     * @memberof RegistrationDetails
     */
    'dhsCaseNumber': string;
    /**
     * Locale for the user
     * @type {string}
     * @memberof RegistrationDetails
     */
    'locale': string;
}
/**
 * Information on how data was shared
 * @export
 * @interface ShareInformation
 */
export interface ShareInformation {
    /**
     * 
     * @type {Sharer}
     * @memberof ShareInformation
     */
    'sharedBy': Sharer;
    /**
     * The date the access delegation was added
     * @type {string}
     * @memberof ShareInformation
     */
    'sharedDate': string;
}
/**
 * A result containing a list of shared collections
 * @export
 * @interface SharedCollectionList
 */
export interface SharedCollectionList {
    /**
     * The collections list
     * @type {Array<SharedCollectionListItem>}
     * @memberof SharedCollectionList
     */
    'sharedCollections': Array<SharedCollectionListItem>;
}
/**
 * Basic details for listing a shared collection
 * @export
 * @interface SharedCollectionListItem
 */
export interface SharedCollectionListItem {
    /**
     * 
     * @type {Owner}
     * @memberof SharedCollectionListItem
     */
    'owner': Owner;
    /**
     * 
     * @type {ShareInformation}
     * @memberof SharedCollectionListItem
     */
    'shareInformation': ShareInformation;
    /**
     * 
     * @type {CollectionListItem}
     * @memberof SharedCollectionListItem
     */
    'collection': CollectionListItem;
}
/**
 * A result containing a list of shared documents
 * @export
 * @interface SharedDocumentsList
 */
export interface SharedDocumentsList {
    /**
     * The documents list
     * @type {Array<SharedDocumentsListItem>}
     * @memberof SharedDocumentsList
     */
    'sharedDocuments': Array<SharedDocumentsListItem>;
}
/**
 * Details for listing a shared document
 * @export
 * @interface SharedDocumentsListItem
 */
export interface SharedDocumentsListItem {
    /**
     * 
     * @type {ShareInformation}
     * @memberof SharedDocumentsListItem
     */
    'latestShareInformation': ShareInformation;
    /**
     * 
     * @type {DocumentListItem}
     * @memberof SharedDocumentsListItem
     */
    'document': DocumentListItem;
}
/**
 * A user who shared information
 * @export
 * @interface Sharer
 */
export interface Sharer {
    /**
     * The user id
     * @type {string}
     * @memberof Sharer
     */
    'id': string;
    /**
     * The users email address
     * @type {string}
     * @memberof Sharer
     */
    'email': string | null;
    /**
     * The users name or email address, if name not provided
     * @type {string}
     * @memberof Sharer
     */
    'name': string;
}
/**
 * A user
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user id
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * The users given name
     * @type {string}
     * @memberof User
     */
    'givenName': string | null;
    /**
     * The users family name
     * @type {string}
     * @memberof User
     */
    'familyName': string | null;
    /**
     * Date of birth in format \'mm/dd/yyyy\'
     * @type {string}
     * @memberof User
     */
    'dob': string;
    /**
     * The issued DHS Case Number for this user
     * @type {string}
     * @memberof User
     */
    'dhsCaseNumber': string;
    /**
     * Locale for the user
     * @type {string}
     * @memberof User
     */
    'locale': string;
    /**
     * Whether the terms of use have been accepted for the current user for this application
     * @type {boolean}
     * @memberof User
     */
    'termsOfUseAccepted'?: boolean;
    /**
     * The users email address
     * @type {string}
     * @memberof User
     */
    'email': string | null;
    /**
     * The users name or email address, if name not provided
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof User
     */
    'links': Array<Link>;
}
/**
 * Delegated access to a user account
 * @export
 * @interface UserDelegatedAccess
 */
export interface UserDelegatedAccess {
    /**
     * The ID for the delegated access
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    'id': string;
    /**
     * The email of the user to delegate access to
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    'email': string;
    /**
     * 
     * @type {Owner}
     * @memberof UserDelegatedAccess
     */
    'allowsAccessToUser'?: Owner;
    /**
     * The date the access delegation was added
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    'createdDate': string;
    /**
     * 
     * @type {UserDelegatedAccessStatus}
     * @memberof UserDelegatedAccess
     */
    'status': UserDelegatedAccessStatus;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof UserDelegatedAccess
     */
    'links': Array<Link>;
}
/**
 * Request data to create delegated access to a user account
 * @export
 * @interface UserDelegatedAccessCreate
 */
export interface UserDelegatedAccessCreate {
    /**
     * The email of the user to delegate access to
     * @type {string}
     * @memberof UserDelegatedAccessCreate
     */
    'email': string;
}
/**
 * A result containing the delagated access information for a user account
 * @export
 * @interface UserDelegatedAccessList
 */
export interface UserDelegatedAccessList {
    /**
     * The list of delegated access to the account
     * @type {Array<UserDelegatedAccess>}
     * @memberof UserDelegatedAccessList
     */
    'delegatedAccess': Array<UserDelegatedAccess>;
}
/**
 * The statuses a delegated access record can be in
 * @export
 * @enum {string}
 */

export const UserDelegatedAccessStatus = {
    InvitationSent: 'INVITATION_SENT',
    InvitationExpired: 'INVITATION_EXPIRED',
    Active: 'ACTIVE'
} as const;

export type UserDelegatedAccessStatus = typeof UserDelegatedAccessStatus[keyof typeof UserDelegatedAccessStatus];



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCollectionDocuments: async (collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('downloadCollectionDocuments', 'collectionId', collectionId)
            // verify required parameter 'documentsDownloadCreate' is not null or undefined
            assertParamExists('downloadCollectionDocuments', 'documentsDownloadCreate', documentsDownloadCreate)
            const localVarPath = `/collections/{collectionId}/documents/downloads`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentsDownloadCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDocuments: async (collectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getCollectionDocuments', 'collectionId', collectionId)
            const localVarPath = `/collections/{collectionId}/documents`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadForCollectionDocuments: async (collectionId: string, downloadId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getDownloadForCollectionDocuments', 'collectionId', collectionId)
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getDownloadForCollectionDocuments', 'downloadId', downloadId)
            const localVarPath = `/collections/{collectionId}/documents/downloads/{downloadId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"downloadId"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByCollectionId: async (collectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getGrantsByCollectionId', 'collectionId', collectionId)
            const localVarPath = `/collections/{collectionId}/grants`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status for a collection
         * @summary Patch collection status
         * @param {string} collectionId ID of collection
         * @param {CollectionStatusPatch} collectionStatusPatch Payload of collection status patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionStatusById: async (collectionId: string, collectionStatusPatch: CollectionStatusPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('patchCollectionStatusById', 'collectionId', collectionId)
            // verify required parameter 'collectionStatusPatch' is not null or undefined
            assertParamExists('patchCollectionStatusById', 'collectionStatusPatch', collectionStatusPatch)
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionStatusPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsDownload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCollectionDocuments(collectionId, documentsDownloadCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionDocuments(collectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionDocuments(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsDownload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadForCollectionDocuments(collectionId, downloadId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantsByCollectionId(collectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionGrantList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrantsByCollectionId(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the status for a collection
         * @summary Patch collection status
         * @param {string} collectionId ID of collection
         * @param {CollectionStatusPatch} collectionStatusPatch Payload of collection status patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCollectionStatusById(collectionId: string, collectionStatusPatch: CollectionStatusPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCollectionStatusById(collectionId, collectionStatusPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: any): AxiosPromise<DocumentsDownload> {
            return localVarFp.downloadCollectionDocuments(collectionId, documentsDownloadCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDocuments(collectionId: string, options?: any): AxiosPromise<DocumentList> {
            return localVarFp.getCollectionDocuments(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: any): AxiosPromise<DocumentsDownload> {
            return localVarFp.getDownloadForCollectionDocuments(collectionId, downloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByCollectionId(collectionId: string, options?: any): AxiosPromise<CollectionGrantList> {
            return localVarFp.getGrantsByCollectionId(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status for a collection
         * @summary Patch collection status
         * @param {string} collectionId ID of collection
         * @param {CollectionStatusPatch} collectionStatusPatch Payload of collection status patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionStatusById(collectionId: string, collectionStatusPatch: CollectionStatusPatch, options?: any): AxiosPromise<Collection> {
            return localVarFp.patchCollectionStatusById(collectionId, collectionStatusPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Download all documents in a collection
     * @summary Download Collection documents
     * @param {string} collectionId ID of collection to download documents for
     * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).downloadCollectionDocuments(collectionId, documentsDownloadCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get documents in a collection
     * @summary Get documents
     * @param {string} collectionId ID of the collection to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionDocuments(collectionId: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionDocuments(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a download for a collections documents
     * @summary Collections download information
     * @param {string} collectionId ID of collection
     * @param {string} downloadId ID of download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getDownloadForCollectionDocuments(collectionId, downloadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns access grants for a single collection
     * @summary Get access grants to collection
     * @param {string} collectionId ID of collection to find grants for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getGrantsByCollectionId(collectionId: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getGrantsByCollectionId(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status for a collection
     * @summary Patch collection status
     * @param {string} collectionId ID of collection
     * @param {CollectionStatusPatch} collectionStatusPatch Payload of collection status patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public patchCollectionStatusById(collectionId: string, collectionStatusPatch: CollectionStatusPatch, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).patchCollectionStatusById(collectionId, collectionStatusPatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DelegateApi - axios parameter creator
 * @export
 */
export const DelegateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDelegatedAccount: async (delegateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegateId' is not null or undefined
            assertParamExists('acceptDelegatedAccount', 'delegateId', delegateId)
            const localVarPath = `/delegates/{delegateId}/accept`
                .replace(`{${"delegateId"}}`, encodeURIComponent(String(delegateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountDelegate: async (delegateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegateId' is not null or undefined
            assertParamExists('deleteAccountDelegate', 'delegateId', delegateId)
            const localVarPath = `/delegates/{delegateId}`
                .replace(`{${"delegateId"}}`, encodeURIComponent(String(delegateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DelegateApi - functional programming interface
 * @export
 */
export const DelegateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DelegateApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDelegatedAccount(delegateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDelegatedAccount(delegateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountDelegate(delegateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountDelegate(delegateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DelegateApi - factory interface
 * @export
 */
export const DelegateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DelegateApiFp(configuration)
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDelegatedAccount(delegateId: string, options?: any): AxiosPromise<UserDelegatedAccess> {
            return localVarFp.acceptDelegatedAccount(delegateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountDelegate(delegateId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountDelegate(delegateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DelegateApi - object-oriented interface
 * @export
 * @class DelegateApi
 * @extends {BaseAPI}
 */
export class DelegateApi extends BaseAPI {
    /**
     * Accept delegated access to a users account for current user
     * @summary Accept delegated access
     * @param {string} delegateId ID of the User Delegated Access record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public acceptDelegatedAccount(delegateId: string, options?: AxiosRequestConfig) {
        return DelegateApiFp(this.configuration).acceptDelegatedAccount(delegateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a delegated users access
     * @param {string} delegateId ID of the User Delegated Access record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public deleteAccountDelegate(delegateId: string, options?: AxiosRequestConfig) {
        return DelegateApiFp(this.configuration).deleteAccountDelegate(delegateId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('deleteDocumentById', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentFileById: async (documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentFileById', 'documentId', documentId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadDocumentFileById', 'fileId', fileId)
            const localVarPath = `/documents/{documentId}/files/{fileId}/download`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)

            if (disposition !== undefined) {
                localVarQueryParameter['disposition'] = disposition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentById', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById: async (documentId: string, documentUpdate: DocumentUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('updateDocumentById', 'documentId', documentId)
            // verify required parameter 'documentUpdate' is not null or undefined
            assertParamExists('updateDocumentById', 'documentUpdate', documentUpdate)
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDownload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentFileById(documentId, fileId, disposition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentById(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentById(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentById(documentId, documentUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById(documentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: any): AxiosPromise<FileDownload> {
            return localVarFp.downloadDocumentFileById(documentId, fileId, disposition, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById(documentId: string, options?: any): AxiosPromise<Document> {
            return localVarFp.getDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateDocumentById(documentId, documentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a document
     * @param {string} documentId ID of Document to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocumentById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).deleteDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
     * @summary File download information
     * @param {string} documentId ID of document
     * @param {string} fileId ID of file in the document
     * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).downloadDocumentFileById(documentId, fileId, disposition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single document. This will be audited as a document view by the current user
     * @summary Find document by ID
     * @param {string} documentId ID of document to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocumentById(documentId: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing document
     * @param {string} documentId ID of the document that needs to be updated
     * @param {DocumentUpdate} documentUpdate Updates a document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).updateDocumentById(documentId, documentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept application Terms of Use for a user with additional registration info
         * @summary Accept Terms and Register
         * @param {string} userId ID of current user
         * @param {RegistrationDetails} registrationDetails Registration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTermsAndRegister: async (userId: string, registrationDetails: RegistrationDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('acceptTermsAndRegister', 'userId', userId)
            // verify required parameter 'registrationDetails' is not null or undefined
            assertParamExists('acceptTermsAndRegister', 'registrationDetails', registrationDetails)
            const localVarPath = `/users/{userId}/accept-terms-and-register`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountDelegate: async (userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addAccountDelegate', 'userId', userId)
            // verify required parameter 'userDelegatedAccessCreate' is not null or undefined
            assertParamExists('addAccountDelegate', 'userDelegatedAccessCreate', userDelegatedAccessCreate)
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDelegatedAccessCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCollection: async (userId: string, collectionCreate: CollectionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserCollection', 'userId', userId)
            // verify required parameter 'collectionCreate' is not null or undefined
            assertParamExists('addUserCollection', 'collectionCreate', collectionCreate)
            const localVarPath = `/users/{userId}/collections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument: async (userId: string, documentCreate: DocumentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserDocument', 'userId', userId)
            // verify required parameter 'documentCreate' is not null or undefined
            assertParamExists('addUserDocument', 'documentCreate', documentCreate)
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivity: async (userId: string, nextToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listAccountActivity', 'userId', userId)
            const localVarPath = `/users/{userId}/activity`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountDelegates: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listAccountDelegates', 'userId', userId)
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserCollections', 'userId', userId)
            const localVarPath = `/users/{userId}/collections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollectionsShared: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserCollectionsShared', 'userId', userId)
            const localVarPath = `/users/{userId}/collections/shared`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserDocuments', 'userId', userId)
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List documents shared by a user to the calling user
         * @summary List documents shared by a user
         * @param {string} userId ID of user who has shared documents to an agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocumentsShared: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserDocumentsShared', 'userId', userId)
            const localVarPath = `/users/{userId}/documents/shared`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit user data.
         * @summary Patch User
         * @param {string} userId ID of current user
         * @param {PatchUserData} patchUserData Patch user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser: async (userId: string, patchUserData: PatchUserData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('patchUser', 'userId', userId)
            // verify required parameter 'patchUserData' is not null or undefined
            assertParamExists('patchUser', 'patchUserData', patchUserData)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "datalocker_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept application Terms of Use for a user with additional registration info
         * @summary Accept Terms and Register
         * @param {string} userId ID of current user
         * @param {RegistrationDetails} registrationDetails Registration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTermsAndRegister(userId: string, registrationDetails: RegistrationDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTermsAndRegister(userId, registrationDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountDelegate(userId, userDelegatedAccessCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserCollection(userId, collectionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserDocument(userId: string, documentCreate: DocumentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserDocument(userId, documentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivity(userId: string, nextToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivity(userId, nextToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountDelegates(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccessList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountDelegates(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCollections(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserCollections(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCollectionsShared(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserCollectionsShared(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDocuments(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserDocuments(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List documents shared by a user to the calling user
         * @summary List documents shared by a user
         * @param {string} userId ID of user who has shared documents to an agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDocumentsShared(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserDocumentsShared(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit user data.
         * @summary Patch User
         * @param {string} userId ID of current user
         * @param {PatchUserData} patchUserData Patch user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUser(userId: string, patchUserData: PatchUserData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUser(userId, patchUserData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Accept application Terms of Use for a user with additional registration info
         * @summary Accept Terms and Register
         * @param {string} userId ID of current user
         * @param {RegistrationDetails} registrationDetails Registration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTermsAndRegister(userId: string, registrationDetails: RegistrationDetails, options?: any): AxiosPromise<User> {
            return localVarFp.acceptTermsAndRegister(userId, registrationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any): AxiosPromise<UserDelegatedAccess> {
            return localVarFp.addAccountDelegate(userId, userDelegatedAccessCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: any): AxiosPromise<Collection> {
            return localVarFp.addUserCollection(userId, collectionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any): AxiosPromise<Document> {
            return localVarFp.addUserDocument(userId, documentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivity(userId: string, nextToken?: string, options?: any): AxiosPromise<ActivityList> {
            return localVarFp.listAccountActivity(userId, nextToken, options).then((request) => request(axios, basePath));
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountDelegates(userId: string, options?: any): AxiosPromise<UserDelegatedAccessList> {
            return localVarFp.listAccountDelegates(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections(userId: string, options?: any): AxiosPromise<CollectionList> {
            return localVarFp.listUserCollections(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollectionsShared(userId: string, options?: any): AxiosPromise<SharedCollectionList> {
            return localVarFp.listUserCollectionsShared(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments(userId: string, options?: any): AxiosPromise<DocumentList> {
            return localVarFp.listUserDocuments(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List documents shared by a user to the calling user
         * @summary List documents shared by a user
         * @param {string} userId ID of user who has shared documents to an agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocumentsShared(userId: string, options?: any): AxiosPromise<SharedCollectionList> {
            return localVarFp.listUserDocumentsShared(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit user data.
         * @summary Patch User
         * @param {string} userId ID of current user
         * @param {PatchUserData} patchUserData Patch user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userId: string, patchUserData: PatchUserData, options?: any): AxiosPromise<User> {
            return localVarFp.patchUser(userId, patchUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Accept application Terms of Use for a user with additional registration info
     * @summary Accept Terms and Register
     * @param {string} userId ID of current user
     * @param {RegistrationDetails} registrationDetails Registration details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public acceptTermsAndRegister(userId: string, registrationDetails: RegistrationDetails, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).acceptTermsAndRegister(userId, registrationDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add delegated access to a user for current user
     * @summary Add delegated access
     * @param {string} userId ID of user to delegate access for
     * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addAccountDelegate(userId, userDelegatedAccessCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new collection for a user
     * @summary Add a new collection
     * @param {string} userId ID of user to create the collection for
     * @param {CollectionCreate} collectionCreate Create a new collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserCollection(userId, collectionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document for a user
     * @summary Add a new document
     * @param {string} userId ID of user to create document for
     * @param {DocumentCreate} documentCreate Create a new document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserDocument(userId: string, documentCreate: DocumentCreate, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserDocument(userId, documentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user details
     * @summary Get user
     * @param {string} userId ID of user to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List audit activity in an account, limited to 50 most recent items.
     * @summary List activity for an account
     * @param {string} userId ID of user to find collections for
     * @param {string} [nextToken] The token to be used to fetch the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listAccountActivity(userId: string, nextToken?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listAccountActivity(userId, nextToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List access delegated to and from a user
     * @summary List delegated access
     * @param {string} userId ID of user to find delegated access items for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listAccountDelegates(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listAccountDelegates(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List collections owned by a user
     * @summary List collections owned by a user
     * @param {string} userId ID of user to find collections for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserCollections(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserCollections(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List collections shared to user
     * @summary List collections shared to user
     * @param {string} userId ID of user to find accessible collections for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserCollectionsShared(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserCollectionsShared(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List documents owned by a user
     * @summary List documents owned by a user
     * @param {string} userId ID of user to find documents for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDocuments(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserDocuments(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List documents shared by a user to the calling user
     * @summary List documents shared by a user
     * @param {string} userId ID of user who has shared documents to an agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDocumentsShared(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserDocumentsShared(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit user data.
     * @summary Patch User
     * @param {string} userId ID of current user
     * @param {PatchUserData} patchUserData Patch user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public patchUser(userId: string, patchUserData: PatchUserData, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).patchUser(userId, patchUserData, options).then((request) => request(this.axios, this.basePath));
    }
}


