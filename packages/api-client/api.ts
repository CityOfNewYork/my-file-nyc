// tslint:disable
/**
 * Data Locker
 * This documents the API for the New America Data Locker project.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Agency
 */
export interface Agency {
    /**
     *
     * @type {string}
     * @memberof Agency
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Agency
     */
    name?: string;
}
/**
 *
 * @export
 * @interface AgencyList
 */
export interface AgencyList {
    /**
     *
     * @type {Array<Agency>}
     * @memberof AgencyList
     */
    agencies?: Array<Agency>;
}
/**
 *
 * @export
 * @interface Document
 */
export interface Document {
    /**
     *
     * @type {string}
     * @memberof Document
     */
    id?: string;
    /**
     * Document description
     * @type {string}
     * @memberof Document
     */
    description?: string;
    /**
     * File source
     * @type {string}
     * @memberof Document
     */
    source?: DocumentSourceEnum;
    /**
     * File format
     * @type {string}
     * @memberof Document
     */
    format?: DocumentFormatEnum;
    /**
     * Document Type
     * @type {string}
     * @memberof Document
     */
    type?: DocumentTypeEnum;
    /**
     *
     * @type {string}
     * @memberof Document
     */
    expiryDate?: string;
    /**
     *
     * @type {string}
     * @memberof Document
     */
    createdDate?: string;
    /**
     *
     * @type {object}
     * @memberof Document
     */
    links?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentSourceEnum {
    PHOTO = 'PHOTO',
    SCAN = 'SCAN'
}
/**
    * @export
    * @enum {string}
    */
export enum DocumentFormatEnum {
    PNG = 'PNG',
    PDF = 'PDF',
    JPEG = 'JPEG'
}
/**
    * @export
    * @enum {string}
    */
export enum DocumentTypeEnum {
    SOCIALSECURITYCARD = 'SOCIAL_SECURITY_CARD',
    BIRTHCERTIFICATE = 'BIRTH_CERTIFICATE',
    PROOFOFINCOME = 'PROOF_OF_INCOME'
}

/**
 *
 * @export
 * @interface DocumentCreate
 */
export interface DocumentCreate {
    /**
     * Document description
     * @type {string}
     * @memberof DocumentCreate
     */
    description?: string;
    /**
     * File format
     * @type {string}
     * @memberof DocumentCreate
     */
    format?: DocumentCreateFormatEnum;
    /**
     * File source
     * @type {string}
     * @memberof DocumentCreate
     */
    source?: DocumentCreateSourceEnum;
    /**
     * Document Type
     * @type {string}
     * @memberof DocumentCreate
     */
    type?: DocumentCreateTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DocumentCreate
     */
    expiryDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentCreateFormatEnum {
    PNG = 'PNG',
    PDF = 'PDF',
    JPEG = 'JPEG'
}
/**
    * @export
    * @enum {string}
    */
export enum DocumentCreateSourceEnum {
    PHOTO = 'PHOTO',
    SCAN = 'SCAN'
}
/**
    * @export
    * @enum {string}
    */
export enum DocumentCreateTypeEnum {
    SOCIALSECURITYCARD = 'SOCIAL_SECURITY_CARD',
    BIRTHCERTIFICATE = 'BIRTH_CERTIFICATE',
    PROOFOFINCOME = 'PROOF_OF_INCOME'
}

/**
 *
 * @export
 * @interface DocumentGrant
 */
export interface DocumentGrant {
    /**
     *
     * @type {string}
     * @memberof DocumentGrant
     */
    id?: string;
    /**
     * Document Grant Type
     * @type {string}
     * @memberof DocumentGrant
     */
    type?: DocumentGrantTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DocumentGrant
     */
    createdDate?: string;
    /**
     *
     * @type {DocumentGrantCreateAgencyDetails}
     * @memberof DocumentGrant
     */
    agencyDetails?: DocumentGrantCreateAgencyDetails;
    /**
     *
     * @type {object}
     * @memberof DocumentGrant
     */
    links?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentGrantTypeEnum {
    AGENCYACCESS = 'AGENCY_ACCESS'
}

/**
 *
 * @export
 * @interface DocumentGrantCreate
 */
export interface DocumentGrantCreate {
    /**
     * Document Grant Type
     * @type {string}
     * @memberof DocumentGrantCreate
     */
    type?: DocumentGrantCreateTypeEnum;
    /**
     *
     * @type {DocumentGrantCreateAgencyDetails}
     * @memberof DocumentGrantCreate
     */
    agencyDetails?: DocumentGrantCreateAgencyDetails;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentGrantCreateTypeEnum {
    AGENCYACCESS = 'AGENCY_ACCESS'
}

/**
 *
 * @export
 * @interface DocumentGrantCreateAgencyDetails
 */
export interface DocumentGrantCreateAgencyDetails {
    /**
     * The ID of the agency
     * @type {string}
     * @memberof DocumentGrantCreateAgencyDetails
     */
    id?: string;
}
/**
 *
 * @export
 * @interface DocumentGrantList
 */
export interface DocumentGrantList {
    /**
     *
     * @type {Array<DocumentGrant>}
     * @memberof DocumentGrantList
     */
    documents?: Array<DocumentGrant>;
}
/**
 *
 * @export
 * @interface DocumentList
 */
export interface DocumentList {
    /**
     *
     * @type {Array<DocumentListItem>}
     * @memberof DocumentList
     */
    documents?: Array<DocumentListItem>;
}
/**
 *
 * @export
 * @interface DocumentListItem
 */
export interface DocumentListItem {
    /**
     *
     * @type {string}
     * @memberof DocumentListItem
     */
    id?: string;
    /**
     * Document Type
     * @type {string}
     * @memberof DocumentListItem
     */
    type?: DocumentListItemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentListItemTypeEnum {
    SOCIALSECURITYCARD = 'SOCIAL_SECURITY_CARD',
    BIRTHCERTIFICATE = 'BIRTH_CERTIFICATE',
    PROOFOFINCOME = 'PROOF_OF_INCOME'
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    givenName?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    familyName?: string;
    /**
     *
     * @type {object}
     * @memberof User
     */
    links?: object;
}
/**
 *
 * @export
 * @interface UserDelegatedAccess
 */
export interface UserDelegatedAccess {
    /**
     *
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    email?: string;
    /**
     *
     * @type {User}
     * @memberof UserDelegatedAccess
     */
    allowsAccessToUser?: User;
    /**
     *
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    createdDate?: string;
    /**
     *
     * @type {object}
     * @memberof UserDelegatedAccess
     */
    links?: object;
}
/**
 *
 * @export
 * @interface UserDelegatedAccessCreate
 */
export interface UserDelegatedAccessCreate {
    /**
     *
     * @type {string}
     * @memberof UserDelegatedAccessCreate
     */
    email?: string;
}
/**
 *
 * @export
 * @interface UserDelegatedAccessList
 */
export interface UserDelegatedAccessList {
    /**
     *
     * @type {Array<UserDelegatedAccess>}
     * @memberof UserDelegatedAccessList
     */
    delegatedAccess?: Array<UserDelegatedAccess>;
}

/**
 * AgencyApi - axios parameter creator
 * @export
 */
export const AgencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List agencies in current city
         * @summary List agencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgencies: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/agencies`;
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgencyApi - functional programming interface
 * @export
 */
export const AgencyApiFp = function (configuration?: Configuration) {
    return {
        /**
         * List agencies in current city
         * @summary List agencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgencies(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgencyList>> {
            const localVarAxiosArgs = await AgencyApiAxiosParamCreator(configuration).listAgencies(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgencyApi - factory interface
 * @export
 */
export const AgencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List agencies in current city
         * @summary List agencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgencies(options?: any): AxiosPromise<AgencyList> {
            return AgencyApiFp(configuration).listAgencies(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgencyApi - object-oriented interface
 * @export
 * @class AgencyApi
 * @extends {BaseAPI}
 */
export class AgencyApi extends BaseAPI {
    /**
     * List agencies in current city
     * @summary List agencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgencyApi
     */
    public listAgencies(options?: any) {
        return AgencyApiFp(this.configuration).listAgencies(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Grant access to a document
         * @summary Create a document grant
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentGrantCreate} documentGrantCreate Create a document grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrantForDocument: async (documentId: string, documentGrantCreate: DocumentGrantCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling createGrantForDocument.');
            }
            // verify required parameter 'documentGrantCreate' is not null or undefined
            if (documentGrantCreate === null || documentGrantCreate === undefined) {
                throw new RequiredError('documentGrantCreate', 'Required parameter documentGrantCreate was null or undefined when calling createGrantForDocument.');
            }
            const localVarPath = `/documents/{documentId}/grants`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof documentGrantCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(documentGrantCreate !== undefined ? documentGrantCreate : {}) : (documentGrantCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById: async (documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling deleteDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a document grant
         * @param {string} documentId ID of Document the Grant belongs to
         * @param {string} grantId ID of the Document Grant to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentGrantById: async (documentId: string, grantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling deleteDocumentGrantById.');
            }
            // verify required parameter 'grantId' is not null or undefined
            if (grantId === null || grantId === undefined) {
                throw new RequiredError('grantId', 'Required parameter grantId was null or undefined when calling deleteDocumentGrantById.');
            }
            const localVarPath = `/documents/{documentId}/grants/{grantId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"grantId"}}`, encodeURIComponent(String(grantId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single document
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById: async (documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling getDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns access grants for a single document
         * @summary Get access grants
         * @param {string} documentId ID of document to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByDocumentId: async (documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling getGrantsByDocumentId.');
            }
            const localVarPath = `/documents/{documentId}/grants`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentCreate} documentCreate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById: async (documentId: string, documentCreate: DocumentCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId', 'Required parameter documentId was null or undefined when calling updateDocumentById.');
            }
            // verify required parameter 'documentCreate' is not null or undefined
            if (documentCreate === null || documentCreate === undefined) {
                throw new RequiredError('documentCreate', 'Required parameter documentCreate was null or undefined when calling updateDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof documentCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(documentCreate !== undefined ? documentCreate : {}) : (documentCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Grant access to a document
         * @summary Create a document grant
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentGrantCreate} documentGrantCreate Create a document grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGrantForDocument(documentId: string, documentGrantCreate: DocumentGrantCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentGrant>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).createGrantForDocument(documentId, documentGrantCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentById(documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).deleteDocumentById(documentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Deletes a document grant
         * @param {string} documentId ID of Document the Grant belongs to
         * @param {string} grantId ID of the Document Grant to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentGrantById(documentId: string, grantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).deleteDocumentGrantById(documentId, grantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single document
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentById(documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).getDocumentById(documentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns access grants for a single document
         * @summary Get access grants
         * @param {string} documentId ID of document to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantsByDocumentId(documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentGrantList>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).getGrantsByDocumentId(documentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentCreate} documentCreate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentById(documentId: string, documentCreate: DocumentCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).updateDocumentById(documentId, documentCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Grant access to a document
         * @summary Create a document grant
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentGrantCreate} documentGrantCreate Create a document grant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrantForDocument(documentId: string, documentGrantCreate: DocumentGrantCreate, options?: any): AxiosPromise<DocumentGrant> {
            return DocumentApiFp(configuration).createGrantForDocument(documentId, documentGrantCreate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById(documentId: string, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).deleteDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a document grant
         * @param {string} documentId ID of Document the Grant belongs to
         * @param {string} grantId ID of the Document Grant to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentGrantById(documentId: string, grantId: string, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).deleteDocumentGrantById(documentId, grantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single document
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById(documentId: string, options?: any): AxiosPromise<Document> {
            return DocumentApiFp(configuration).getDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns access grants for a single document
         * @summary Get access grants
         * @param {string} documentId ID of document to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByDocumentId(documentId: string, options?: any): AxiosPromise<DocumentGrantList> {
            return DocumentApiFp(configuration).getGrantsByDocumentId(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentCreate} documentCreate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById(documentId: string, documentCreate: DocumentCreate, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).updateDocumentById(documentId, documentCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Grant access to a document
     * @summary Create a document grant
     * @param {string} documentId ID of the document that needs to be updated
     * @param {DocumentGrantCreate} documentGrantCreate Create a document grant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createGrantForDocument(documentId: string, documentGrantCreate: DocumentGrantCreate, options?: any) {
        return DocumentApiFp(this.configuration).createGrantForDocument(documentId, documentGrantCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a document
     * @param {string} documentId ID of Document to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocumentById(documentId: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a document grant
     * @param {string} documentId ID of Document the Grant belongs to
     * @param {string} grantId ID of the Document Grant to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocumentGrantById(documentId: string, grantId: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDocumentGrantById(documentId, grantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single document
     * @summary Find document by ID
     * @param {string} documentId ID of document to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocumentById(documentId: string, options?: any) {
        return DocumentApiFp(this.configuration).getDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns access grants for a single document
     * @summary Get access grants
     * @param {string} documentId ID of document to find grants for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getGrantsByDocumentId(documentId: string, options?: any) {
        return DocumentApiFp(this.configuration).getGrantsByDocumentId(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates an existing document
     * @param {string} documentId ID of the document that needs to be updated
     * @param {DocumentCreate} documentCreate Updates a document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocumentById(documentId: string, documentCreate: DocumentCreate, options?: any) {
        return DocumentApiFp(this.configuration).updateDocumentById(documentId, documentCreate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDelegatedAccess: async (userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling addDelegatedAccess.');
            }
            // verify required parameter 'userDelegatedAccessCreate' is not null or undefined
            if (userDelegatedAccessCreate === null || userDelegatedAccessCreate === undefined) {
                throw new RequiredError('userDelegatedAccessCreate', 'Required parameter userDelegatedAccessCreate was null or undefined when calling addDelegatedAccess.');
            }
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof userDelegatedAccessCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userDelegatedAccessCreate !== undefined ? userDelegatedAccessCreate : {}) : (userDelegatedAccessCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument: async (userId: string, documentCreate: DocumentCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling addUserDocument.');
            }
            // verify required parameter 'documentCreate' is not null or undefined
            if (documentCreate === null || documentCreate === undefined) {
                throw new RequiredError('documentCreate', 'Required parameter documentCreate was null or undefined when calling addUserDocument.');
            }
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof documentCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(documentCreate !== undefined ? documentCreate : {}) : (documentCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List agencies user is part of in current city
         * @summary List agencies for user
         * @param {string} userId ID of user to find agencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgenciesForUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling listAgenciesForUser.');
            }
            const localVarPath = `/users/{userId}/agencies`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDelegatedAccess: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling listDelegatedAccess.');
            }
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments: async (userId: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling listUserDocuments.');
            }
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List documents shared to user
         * @summary List documents shared to user
         * @param {string} userId ID of user to find accessible documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocumentsShared: async (userId: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling listUserDocumentsShared.');
            }
            const localVarPath = `/users/{userId}/documents/shared`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj: any = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("datalocker_auth", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDelegatedAccess(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccess>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).addDelegatedAccess(userId, userDelegatedAccessCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).addUserDocument(userId, documentCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List agencies user is part of in current city
         * @summary List agencies for user
         * @param {string} userId ID of user to find agencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgenciesForUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgencyList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listAgenciesForUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDelegatedAccess(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccessList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listDelegatedAccess(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDocuments(userId: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listUserDocuments(userId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List documents shared to user
         * @summary List documents shared to user
         * @param {string} userId ID of user to find accessible documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDocumentsShared(userId: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listUserDocumentsShared(userId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDelegatedAccess(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any): AxiosPromise<UserDelegatedAccess> {
            return UserApiFp(configuration).addDelegatedAccess(userId, userDelegatedAccessCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any): AxiosPromise<Document> {
            return UserApiFp(configuration).addUserDocument(userId, documentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List agencies user is part of in current city
         * @summary List agencies for user
         * @param {string} userId ID of user to find agencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgenciesForUser(userId: string, options?: any): AxiosPromise<AgencyList> {
            return UserApiFp(configuration).listAgenciesForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDelegatedAccess(userId: string, options?: any): AxiosPromise<UserDelegatedAccessList> {
            return UserApiFp(configuration).listDelegatedAccess(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments(userId: string, search?: string, options?: any): AxiosPromise<DocumentList> {
            return UserApiFp(configuration).listUserDocuments(userId, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List documents shared to user
         * @summary List documents shared to user
         * @param {string} userId ID of user to find accessible documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocumentsShared(userId: string, search?: string, options?: any): AxiosPromise<DocumentList> {
            return UserApiFp(configuration).listUserDocumentsShared(userId, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Add delegated access to a user for current user
     * @summary Add delegated access
     * @param {string} userId ID of user to delegate access for
     * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addDelegatedAccess(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any) {
        return UserApiFp(this.configuration).addDelegatedAccess(userId, userDelegatedAccessCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document for a user
     * @summary Add a new document
     * @param {string} userId ID of user to create document for
     * @param {DocumentCreate} documentCreate Create a new document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any) {
        return UserApiFp(this.configuration).addUserDocument(userId, documentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user details
     * @summary Get user
     * @param {string} userId ID of user to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List agencies user is part of in current city
     * @summary List agencies for user
     * @param {string} userId ID of user to find agencies for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listAgenciesForUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).listAgenciesForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List access delegated to and from a user
     * @summary List delegated access
     * @param {string} userId ID of user to find delegated access items for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listDelegatedAccess(userId: string, options?: any) {
        return UserApiFp(this.configuration).listDelegatedAccess(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List documents owned by a user
     * @summary List documents owned by a user
     * @param {string} userId ID of user to find documents for
     * @param {string} [search] Search string to narrow down list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDocuments(userId: string, search?: string, options?: any) {
        return UserApiFp(this.configuration).listUserDocuments(userId, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List documents shared to user
     * @summary List documents shared to user
     * @param {string} userId ID of user to find accessible documents for
     * @param {string} [search] Search string to narrow down list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDocumentsShared(userId: string, search?: string, options?: any) {
        return UserApiFp(this.configuration).listUserDocumentsShared(userId, search, options).then((request) => request(this.axios, this.basePath));
    }

}


