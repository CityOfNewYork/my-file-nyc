/* tslint:disable */
/* eslint-disable */
/**
 * Data Locker
 * This documents the API for the New America Data Locker project.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An activity item
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {ActivityPrincipal}
     * @memberof Activity
     */
    principal: ActivityPrincipal;
    /**
     * 
     * @type {ActivityActionTypeEnum}
     * @memberof Activity
     */
    type: ActivityActionTypeEnum;
    /**
     * The ID of the request that created this action
     * @type {string}
     * @memberof Activity
     */
    requestId: string;
    /**
     * The date the activity happened
     * @type {string}
     * @memberof Activity
     */
    date: string;
    /**
     * 
     * @type {ActivityResource}
     * @memberof Activity
     */
    resource: ActivityResource;
    /**
     * The list of any additional resources part of this activity
     * @type {Array<ActivityResource>}
     * @memberof Activity
     */
    relatedResources?: Array<ActivityResource>;
}
/**
 * The type of an activity action
 * @export
 * @enum {string}
 */
export enum ActivityActionTypeEnum {
    COLLECTIONCREATED = 'COLLECTION.CREATED',
    DOCUMENTCREATED = 'DOCUMENT.CREATED',
    DOCUMENTACCESSED = 'DOCUMENT.ACCESSED',
    DOCUMENTEDITED = 'DOCUMENT.EDITED',
    DOCUMENTDELETED = 'DOCUMENT.DELETED',
    DELEGATEDUSERINVITED = 'DELEGATEDUSER.INVITED',
    DELEGATEDUSERINVITEACCEPTED = 'DELEGATEDUSER.INVITE_ACCEPTED',
    DELEGATEDUSERDELETED = 'DELEGATEDUSER.DELETED',
    USERTERMSACCEPTED = 'USER.TERMS_ACCEPTED'
}

/**
 * A list of account activity
 * @export
 * @interface ActivityList
 */
export interface ActivityList {
    /**
     * The list of account activity
     * @type {Array<Activity>}
     * @memberof ActivityList
     */
    activity: Array<Activity>;
    /**
     * The token to use to fetch further account activity
     * @type {string}
     * @memberof ActivityList
     */
    nextToken: string | null;
}
/**
 * Details on the user principal that performed the activity
 * @export
 * @interface ActivityPrincipal
 */
export interface ActivityPrincipal {
    /**
     * The ID of the principal
     * @type {string}
     * @memberof ActivityPrincipal
     */
    id: string;
    /**
     * The consistent name of the principal, generally the user email, for human readable reference.
     * @type {string}
     * @memberof ActivityPrincipal
     */
    name: string;
}
/**
 * A resource (or record) related to an activity
 * @export
 * @interface ActivityResource
 */
export interface ActivityResource {
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActivityResource
     */
    id: string;
    /**
     * The name of the resource, at the time of the activity, for human readable reference.
     * @type {string}
     * @memberof ActivityResource
     */
    name: string;
    /**
     * 
     * @type {ActivityResourceTypeEnum}
     * @memberof ActivityResource
     */
    type: ActivityResourceTypeEnum;
    /**
     * The list of any changes made to the resource
     * @type {Array<ActivityResourceChange>}
     * @memberof ActivityResource
     */
    changes?: Array<ActivityResourceChange>;
}
/**
 * Changes made to a resource
 * @export
 * @interface ActivityResourceChange
 */
export interface ActivityResourceChange {
    /**
     * The name of the field that was change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    field: string;
    /**
     * The value of the field before the change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    oldValue: string | null;
    /**
     * The value of the field after the change
     * @type {string}
     * @memberof ActivityResourceChange
     */
    newValue: string | null;
}
/**
 * The type of an activity resource
 * @export
 * @enum {string}
 */
export enum ActivityResourceTypeEnum {
    COLLECTION = 'COLLECTION',
    COLLECTIONINDIVIDUALEMAILGRANT = 'COLLECTION.INDIVIDUAL_EMAIL_GRANT',
    DOCUMENT = 'DOCUMENT',
    DOCUMENTFILE = 'DOCUMENT.FILE',
    DELEGATEDUSER = 'DELEGATEDUSER',
    USER = 'USER'
}

/**
 * A collection of documents
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * The ID of the collection
     * @type {string}
     * @memberof Collection
     */
    id: string;
    /**
     * The name of the collection
     * @type {string}
     * @memberof Collection
     */
    name: string;
    /**
     * The date the collection was created
     * @type {string}
     * @memberof Collection
     */
    createdDate: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof Collection
     */
    links: Array<Link>;
}
/**
 * Request data to create a collection
 * @export
 * @interface CollectionCreate
 */
export interface CollectionCreate {
    /**
     * The name of the collection
     * @type {string}
     * @memberof CollectionCreate
     */
    name: string;
    /**
     * The ID\'s of the Documents to add to this collection
     * @type {Array<string>}
     * @memberof CollectionCreate
     */
    documentIds: Array<string>;
    /**
     * The email addresses of individuals to grant access to this collection
     * @type {Array<string>}
     * @memberof CollectionCreate
     */
    individualEmailAddresses: Array<string>;
}
/**
 * A collection access grant
 * @export
 * @interface CollectionGrant
 */
export interface CollectionGrant {
    /**
     * The ID of the grant
     * @type {string}
     * @memberof CollectionGrant
     */
    id: string;
    /**
     * 
     * @type {CollectionGrantType}
     * @memberof CollectionGrant
     */
    type: CollectionGrantType;
    /**
     * The date the grant was created
     * @type {string}
     * @memberof CollectionGrant
     */
    createdDate: string;
    /**
     * The email address that has been granted access
     * @type {string}
     * @memberof CollectionGrant
     */
    individualEmailAddress: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof CollectionGrant
     */
    links: Array<Link>;
}
/**
 * A result containing a list of access grants to a document
 * @export
 * @interface CollectionGrantList
 */
export interface CollectionGrantList {
    /**
     * The list of grants for a collection
     * @type {Array<CollectionGrant>}
     * @memberof CollectionGrantList
     */
    collectionGrants: Array<CollectionGrant>;
}
/**
 * The valid types for access grants to a collection
 * @export
 * @enum {string}
 */
export enum CollectionGrantType {
    INDIVIDUALEMAIL = 'INDIVIDUAL_EMAIL'
}

/**
 * A result containing a list of collections
 * @export
 * @interface CollectionList
 */
export interface CollectionList {
    /**
     * The collections list
     * @type {Array<CollectionListItem>}
     * @memberof CollectionList
     */
    collections: Array<CollectionListItem>;
}
/**
 * Basic details for listing a collection
 * @export
 * @interface CollectionListItem
 */
export interface CollectionListItem {
    /**
     * The ID of the collection
     * @type {string}
     * @memberof CollectionListItem
     */
    id: string;
    /**
     * The name of the collection
     * @type {string}
     * @memberof CollectionListItem
     */
    name: string;
    /**
     * The date the collection was created
     * @type {string}
     * @memberof CollectionListItem
     */
    createdDate: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof CollectionListItem
     */
    links: Array<Link>;
}
/**
 * A document
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * The ID of the document
     * @type {string}
     * @memberof Document
     */
    id: string;
    /**
     * Document name (system or user provided)
     * @type {string}
     * @memberof Document
     */
    name: string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof Document
     */
    description: string | null;
    /**
     * Date the document was created
     * @type {string}
     * @memberof Document
     */
    createdDate: string;
    /**
     * The files in the document
     * @type {Array<DocumentFile>}
     * @memberof Document
     */
    files: Array<DocumentFile>;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof Document
     */
    links: Array<Link>;
}
/**
 * Request data to create a document
 * @export
 * @interface DocumentCreate
 */
export interface DocumentCreate {
    /**
     * Document name (system or user provided)
     * @type {string}
     * @memberof DocumentCreate
     */
    name: string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof DocumentCreate
     */
    description?: string;
    /**
     * The files that are part of the document
     * @type {Array<DocumentCreateFile>}
     * @memberof DocumentCreate
     */
    files: Array<DocumentCreateFile>;
}
/**
 * Request data to create a file of a document
 * @export
 * @interface DocumentCreateFile
 */
export interface DocumentCreateFile {
    /**
     * File original name
     * @type {string}
     * @memberof DocumentCreateFile
     */
    name: string;
    /**
     * 
     * @type {FileContentTypeEnum}
     * @memberof DocumentCreateFile
     */
    contentType: FileContentTypeEnum;
    /**
     * SHA256 Checksum of file content
     * @type {string}
     * @memberof DocumentCreateFile
     */
    sha256Checksum: string;
    /**
     * Content length in bytes of the file
     * @type {number}
     * @memberof DocumentCreateFile
     */
    contentLength: number;
}
/**
 * A file of a document
 * @export
 * @interface DocumentFile
 */
export interface DocumentFile {
    /**
     * The ID of the document file
     * @type {string}
     * @memberof DocumentFile
     */
    id: string;
    /**
     * File original name
     * @type {string}
     * @memberof DocumentFile
     */
    name: string;
    /**
     * 
     * @type {FileContentTypeEnum}
     * @memberof DocumentFile
     */
    contentType: FileContentTypeEnum;
    /**
     * SHA256 Checksum of file content
     * @type {string}
     * @memberof DocumentFile
     */
    sha256Checksum: string;
    /**
     * Content length in bytes of the file
     * @type {number}
     * @memberof DocumentFile
     */
    contentLength: number;
    /**
     * Date the document file was created
     * @type {string}
     * @memberof DocumentFile
     */
    createdDate: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof DocumentFile
     */
    links: Array<Link>;
}
/**
 * A result containing a list of documents
 * @export
 * @interface DocumentList
 */
export interface DocumentList {
    /**
     * The documents list
     * @type {Array<DocumentListItem>}
     * @memberof DocumentList
     */
    documents: Array<DocumentListItem>;
}
/**
 * A listed document, deliberately minimal
 * @export
 * @interface DocumentListItem
 */
export interface DocumentListItem {
    /**
     * The ID of the document
     * @type {string}
     * @memberof DocumentListItem
     */
    id: string;
    /**
     * The human readable name of the document
     * @type {string}
     * @memberof DocumentListItem
     */
    name: string;
    /**
     * Date the document was created
     * @type {string}
     * @memberof DocumentListItem
     */
    createdDate: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof DocumentListItem
     */
    links: Array<Link>;
}
/**
 * Request data to update a document
 * @export
 * @interface DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * Document name.
     * @type {string}
     * @memberof DocumentUpdate
     */
    name?: string;
    /**
     * Document description or notes
     * @type {string}
     * @memberof DocumentUpdate
     */
    description?: string | null;
}
/**
 * Details about a document download
 * @export
 * @interface DocumentsDownload
 */
export interface DocumentsDownload {
    /**
     * The ID of the download
     * @type {string}
     * @memberof DocumentsDownload
     */
    id: string;
    /**
     * 
     * @type {DocumentsDownloadStatusEnum}
     * @memberof DocumentsDownload
     */
    status: DocumentsDownloadStatusEnum;
    /**
     * 
     * @type {FileDownload}
     * @memberof DocumentsDownload
     */
    fileDownload: FileDownload | null;
}
/**
 * Request data to create a download of a set of documents
 * @export
 * @interface DocumentsDownloadCreate
 */
export interface DocumentsDownloadCreate {
    /**
     * 
     * @type {DocumentsDownloadFormatEnum}
     * @memberof DocumentsDownloadCreate
     */
    format: DocumentsDownloadFormatEnum;
}
/**
 * The valid formats for a requested download
 * @export
 * @enum {string}
 */
export enum DocumentsDownloadFormatEnum {
    ZIP = 'ZIP'
}

/**
 * The valid statuses for a requested download
 * @export
 * @enum {string}
 */
export enum DocumentsDownloadStatusEnum {
    SUCCESS = 'SUCCESS',
    PENDING = 'PENDING'
}

/**
 * The accepted content type for files
 * @export
 * @enum {string}
 */
export enum FileContentTypeEnum {
    ApplicationPdf = 'application/pdf',
    ImageJpeg = 'image/jpeg',
    ImagePng = 'image/png',
    ImageTiff = 'image/tiff'
}

/**
 * A result containing a download link to a file
 * @export
 * @interface FileDownload
 */
export interface FileDownload {
    /**
     * The web address (relative or absolute) for the linked resource
     * @type {string}
     * @memberof FileDownload
     */
    href: string;
}
/**
 * The disposition type for the file download
 * @export
 * @enum {string}
 */
export enum FileDownloadDispositionTypeEnum {
    Inline = 'inline',
    Attachment = 'attachment'
}

/**
 * A HATEOS Link
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * The web address (relative or absolute) for the linked resource
     * @type {string}
     * @memberof Link
     */
    href: string;
    /**
     * The relation this linked resource has to the resource it is attached to.
     * @type {string}
     * @memberof Link
     */
    rel: string;
    /**
     * The HTTP method to use to access the linked resource
     * @type {string}
     * @memberof Link
     */
    type: string;
    /**
     * Form data to include in the request
     * @type {{ [key: string]: string; }}
     * @memberof Link
     */
    includeFormData?: { [key: string]: string; };
}
/**
 * A record owner
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The user id
     * @type {string}
     * @memberof Owner
     */
    id: string;
    /**
     * The users given name
     * @type {string}
     * @memberof Owner
     */
    givenName: string | null;
    /**
     * The users family name
     * @type {string}
     * @memberof Owner
     */
    familyName: string | null;
    /**
     * The users name or email address, if name not provided
     * @type {string}
     * @memberof Owner
     */
    name: string;
}
/**
 * A result containing a list of shared collections
 * @export
 * @interface SharedCollectionList
 */
export interface SharedCollectionList {
    /**
     * The collections list
     * @type {Array<SharedCollectionListItem>}
     * @memberof SharedCollectionList
     */
    sharedCollections: Array<SharedCollectionListItem>;
}
/**
 * Basic details for listing a shared collection
 * @export
 * @interface SharedCollectionListItem
 */
export interface SharedCollectionListItem {
    /**
     * 
     * @type {Owner}
     * @memberof SharedCollectionListItem
     */
    owner: Owner;
    /**
     * 
     * @type {CollectionListItem}
     * @memberof SharedCollectionListItem
     */
    collection: CollectionListItem;
}
/**
 * A user
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user id
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * The users given name
     * @type {string}
     * @memberof User
     */
    givenName: string | null;
    /**
     * The users family name
     * @type {string}
     * @memberof User
     */
    familyName: string | null;
    /**
     * Whether the terms of use have been accepted for the current user for this application
     * @type {boolean}
     * @memberof User
     */
    termsOfUseAccepted?: boolean;
    /**
     * The users email address
     * @type {string}
     * @memberof User
     */
    email: string | null;
    /**
     * The users name or email address, if name not provided
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof User
     */
    links: Array<Link>;
}
/**
 * Delegated access to a user account
 * @export
 * @interface UserDelegatedAccess
 */
export interface UserDelegatedAccess {
    /**
     * The ID for the delegated access
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    id: string;
    /**
     * The email of the user to delegate access to
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    email: string;
    /**
     * 
     * @type {Owner}
     * @memberof UserDelegatedAccess
     */
    allowsAccessToUser?: Owner;
    /**
     * The date the access delegation was added
     * @type {string}
     * @memberof UserDelegatedAccess
     */
    createdDate: string;
    /**
     * 
     * @type {UserDelegatedAccessStatus}
     * @memberof UserDelegatedAccess
     */
    status: UserDelegatedAccessStatus;
    /**
     * An array of Links
     * @type {Array<Link>}
     * @memberof UserDelegatedAccess
     */
    links: Array<Link>;
}
/**
 * Request data to create delegated access to a user account
 * @export
 * @interface UserDelegatedAccessCreate
 */
export interface UserDelegatedAccessCreate {
    /**
     * The email of the user to delegate access to
     * @type {string}
     * @memberof UserDelegatedAccessCreate
     */
    email: string;
}
/**
 * A result containing the delagated access information for a user account
 * @export
 * @interface UserDelegatedAccessList
 */
export interface UserDelegatedAccessList {
    /**
     * The list of delegated access to the account
     * @type {Array<UserDelegatedAccess>}
     * @memberof UserDelegatedAccessList
     */
    delegatedAccess: Array<UserDelegatedAccess>;
}
/**
 * The statuses a delegated access record can be in
 * @export
 * @enum {string}
 */
export enum UserDelegatedAccessStatus {
    INVITATIONSENT = 'INVITATION_SENT',
    INVITATIONEXPIRED = 'INVITATION_EXPIRED',
    ACTIVE = 'ACTIVE'
}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCollectionDocuments: async (collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling downloadCollectionDocuments.');
            }
            // verify required parameter 'documentsDownloadCreate' is not null or undefined
            if (documentsDownloadCreate === null || documentsDownloadCreate === undefined) {
                throw new RequiredError('documentsDownloadCreate','Required parameter documentsDownloadCreate was null or undefined when calling downloadCollectionDocuments.');
            }
            const localVarPath = `/collections/{collectionId}/documents/downloads`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentsDownloadCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentsDownloadCreate !== undefined ? documentsDownloadCreate : {}) : (documentsDownloadCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDocuments: async (collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling getCollectionDocuments.');
            }
            const localVarPath = `/collections/{collectionId}/documents`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadForCollectionDocuments: async (collectionId: string, downloadId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling getDownloadForCollectionDocuments.');
            }
            // verify required parameter 'downloadId' is not null or undefined
            if (downloadId === null || downloadId === undefined) {
                throw new RequiredError('downloadId','Required parameter downloadId was null or undefined when calling getDownloadForCollectionDocuments.');
            }
            const localVarPath = `/collections/{collectionId}/documents/downloads/{downloadId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"downloadId"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByCollectionId: async (collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling getGrantsByCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}/grants`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsDownload>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).downloadCollectionDocuments(collectionId, documentsDownloadCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionDocuments(collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).getCollectionDocuments(collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsDownload>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).getDownloadForCollectionDocuments(collectionId, downloadId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrantsByCollectionId(collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionGrantList>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).getGrantsByCollectionId(collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Download all documents in a collection
         * @summary Download Collection documents
         * @param {string} collectionId ID of collection to download documents for
         * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: any): AxiosPromise<DocumentsDownload> {
            return CollectionsApiFp(configuration).downloadCollectionDocuments(collectionId, documentsDownloadCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get documents in a collection
         * @summary Get documents
         * @param {string} collectionId ID of the collection to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDocuments(collectionId: string, options?: any): AxiosPromise<DocumentList> {
            return CollectionsApiFp(configuration).getCollectionDocuments(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a download for a collections documents
         * @summary Collections download information
         * @param {string} collectionId ID of collection
         * @param {string} downloadId ID of download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: any): AxiosPromise<DocumentsDownload> {
            return CollectionsApiFp(configuration).getDownloadForCollectionDocuments(collectionId, downloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns access grants for a single collection
         * @summary Get access grants to collection
         * @param {string} collectionId ID of collection to find grants for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrantsByCollectionId(collectionId: string, options?: any): AxiosPromise<CollectionGrantList> {
            return CollectionsApiFp(configuration).getGrantsByCollectionId(collectionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Download all documents in a collection
     * @summary Download Collection documents
     * @param {string} collectionId ID of collection to download documents for
     * @param {DocumentsDownloadCreate} documentsDownloadCreate Requests a new download to be created for this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public downloadCollectionDocuments(collectionId: string, documentsDownloadCreate: DocumentsDownloadCreate, options?: any) {
        return CollectionsApiFp(this.configuration).downloadCollectionDocuments(collectionId, documentsDownloadCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get documents in a collection
     * @summary Get documents
     * @param {string} collectionId ID of the collection to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionDocuments(collectionId: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollectionDocuments(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a download for a collections documents
     * @summary Collections download information
     * @param {string} collectionId ID of collection
     * @param {string} downloadId ID of download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getDownloadForCollectionDocuments(collectionId: string, downloadId: string, options?: any) {
        return CollectionsApiFp(this.configuration).getDownloadForCollectionDocuments(collectionId, downloadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns access grants for a single collection
     * @summary Get access grants to collection
     * @param {string} collectionId ID of collection to find grants for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getGrantsByCollectionId(collectionId: string, options?: any) {
        return CollectionsApiFp(this.configuration).getGrantsByCollectionId(collectionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DelegateApi - axios parameter creator
 * @export
 */
export const DelegateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDelegatedAccount: async (delegateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegateId' is not null or undefined
            if (delegateId === null || delegateId === undefined) {
                throw new RequiredError('delegateId','Required parameter delegateId was null or undefined when calling acceptDelegatedAccount.');
            }
            const localVarPath = `/delegates/{delegateId}/accept`
                .replace(`{${"delegateId"}}`, encodeURIComponent(String(delegateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountDelegate: async (delegateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegateId' is not null or undefined
            if (delegateId === null || delegateId === undefined) {
                throw new RequiredError('delegateId','Required parameter delegateId was null or undefined when calling deleteAccountDelegate.');
            }
            const localVarPath = `/delegates/{delegateId}`
                .replace(`{${"delegateId"}}`, encodeURIComponent(String(delegateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DelegateApi - functional programming interface
 * @export
 */
export const DelegateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDelegatedAccount(delegateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccess>> {
            const localVarAxiosArgs = await DelegateApiAxiosParamCreator(configuration).acceptDelegatedAccount(delegateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountDelegate(delegateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DelegateApiAxiosParamCreator(configuration).deleteAccountDelegate(delegateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DelegateApi - factory interface
 * @export
 */
export const DelegateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept delegated access to a users account for current user
         * @summary Accept delegated access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDelegatedAccount(delegateId: string, options?: any): AxiosPromise<UserDelegatedAccess> {
            return DelegateApiFp(configuration).acceptDelegatedAccount(delegateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a delegated users access
         * @param {string} delegateId ID of the User Delegated Access record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountDelegate(delegateId: string, options?: any): AxiosPromise<void> {
            return DelegateApiFp(configuration).deleteAccountDelegate(delegateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DelegateApi - object-oriented interface
 * @export
 * @class DelegateApi
 * @extends {BaseAPI}
 */
export class DelegateApi extends BaseAPI {
    /**
     * Accept delegated access to a users account for current user
     * @summary Accept delegated access
     * @param {string} delegateId ID of the User Delegated Access record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public acceptDelegatedAccount(delegateId: string, options?: any) {
        return DelegateApiFp(this.configuration).acceptDelegatedAccount(delegateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a delegated users access
     * @param {string} delegateId ID of the User Delegated Access record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public deleteAccountDelegate(delegateId: string, options?: any) {
        return DelegateApiFp(this.configuration).deleteAccountDelegate(delegateId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById: async (documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling deleteDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentFileById: async (documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling downloadDocumentFileById.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling downloadDocumentFileById.');
            }
            const localVarPath = `/documents/{documentId}/files/{fileId}/download`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (disposition !== undefined) {
                localVarQueryParameter['disposition'] = disposition;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById: async (documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling getDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById: async (documentId: string, documentUpdate: DocumentUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling updateDocumentById.');
            }
            // verify required parameter 'documentUpdate' is not null or undefined
            if (documentUpdate === null || documentUpdate === undefined) {
                throw new RequiredError('documentUpdate','Required parameter documentUpdate was null or undefined when calling updateDocumentById.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentUpdate !== undefined ? documentUpdate : {}) : (documentUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentById(documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).deleteDocumentById(documentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDownload>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).downloadDocumentFileById(documentId, fileId, disposition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentById(documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).getDocumentById(documentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).updateDocumentById(documentId, documentUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a document
         * @param {string} documentId ID of Document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentById(documentId: string, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).deleteDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
         * @summary File download information
         * @param {string} documentId ID of document
         * @param {string} fileId ID of file in the document
         * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: any): AxiosPromise<FileDownload> {
            return DocumentApiFp(configuration).downloadDocumentFileById(documentId, fileId, disposition, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single document. This will be audited as a document view by the current user
         * @summary Find document by ID
         * @param {string} documentId ID of document to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById(documentId: string, options?: any): AxiosPromise<Document> {
            return DocumentApiFp(configuration).getDocumentById(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing document
         * @param {string} documentId ID of the document that needs to be updated
         * @param {DocumentUpdate} documentUpdate Updates a document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).updateDocumentById(documentId, documentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a document
     * @param {string} documentId ID of Document to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocumentById(documentId: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a presigned POST URL to download the specified file. This will be audited as a download by the end user.
     * @summary File download information
     * @param {string} documentId ID of document
     * @param {string} fileId ID of file in the document
     * @param {FileDownloadDispositionTypeEnum} [disposition] Content Disposition for the file download. Will default to attachment if none given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public downloadDocumentFileById(documentId: string, fileId: string, disposition?: FileDownloadDispositionTypeEnum, options?: any) {
        return DocumentApiFp(this.configuration).downloadDocumentFileById(documentId, fileId, disposition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single document. This will be audited as a document view by the current user
     * @summary Find document by ID
     * @param {string} documentId ID of document to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocumentById(documentId: string, options?: any) {
        return DocumentApiFp(this.configuration).getDocumentById(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing document
     * @param {string} documentId ID of the document that needs to be updated
     * @param {DocumentUpdate} documentUpdate Updates a document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocumentById(documentId: string, documentUpdate: DocumentUpdate, options?: any) {
        return DocumentApiFp(this.configuration).updateDocumentById(documentId, documentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept application Terms of Use for a user
         * @summary Accept Terms
         * @param {string} userId ID of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTerms: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling acceptTerms.');
            }
            const localVarPath = `/users/{userId}/accept-terms`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountDelegate: async (userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addAccountDelegate.');
            }
            // verify required parameter 'userDelegatedAccessCreate' is not null or undefined
            if (userDelegatedAccessCreate === null || userDelegatedAccessCreate === undefined) {
                throw new RequiredError('userDelegatedAccessCreate','Required parameter userDelegatedAccessCreate was null or undefined when calling addAccountDelegate.');
            }
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userDelegatedAccessCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userDelegatedAccessCreate !== undefined ? userDelegatedAccessCreate : {}) : (userDelegatedAccessCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCollection: async (userId: string, collectionCreate: CollectionCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addUserCollection.');
            }
            // verify required parameter 'collectionCreate' is not null or undefined
            if (collectionCreate === null || collectionCreate === undefined) {
                throw new RequiredError('collectionCreate','Required parameter collectionCreate was null or undefined when calling addUserCollection.');
            }
            const localVarPath = `/users/{userId}/collections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof collectionCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(collectionCreate !== undefined ? collectionCreate : {}) : (collectionCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument: async (userId: string, documentCreate: DocumentCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addUserDocument.');
            }
            // verify required parameter 'documentCreate' is not null or undefined
            if (documentCreate === null || documentCreate === undefined) {
                throw new RequiredError('documentCreate','Required parameter documentCreate was null or undefined when calling addUserDocument.');
            }
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentCreate !== undefined ? documentCreate : {}) : (documentCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivity: async (userId: string, nextToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listAccountActivity.');
            }
            const localVarPath = `/users/{userId}/activity`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountDelegates: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listAccountDelegates.');
            }
            const localVarPath = `/users/{userId}/delegates`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections: async (userId: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserCollections.');
            }
            const localVarPath = `/users/{userId}/collections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollectionsShared: async (userId: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserCollectionsShared.');
            }
            const localVarPath = `/users/{userId}/collections/shared`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments: async (userId: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserDocuments.');
            }
            const localVarPath = `/users/{userId}/documents`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication datalocker_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("datalocker_auth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept application Terms of Use for a user
         * @summary Accept Terms
         * @param {string} userId ID of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTerms(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).acceptTerms(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccess>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).addAccountDelegate(userId, userDelegatedAccessCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).addUserCollection(userId, collectionCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).addUserDocument(userId, documentCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivity(userId: string, nextToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listAccountActivity(userId, nextToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountDelegates(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelegatedAccessList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listAccountDelegates(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCollections(userId: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listUserCollections(userId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCollectionsShared(userId: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedCollectionList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listUserCollectionsShared(userId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDocuments(userId: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).listUserDocuments(userId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept application Terms of Use for a user
         * @summary Accept Terms
         * @param {string} userId ID of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTerms(userId: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).acceptTerms(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add delegated access to a user for current user
         * @summary Add delegated access
         * @param {string} userId ID of user to delegate access for
         * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any): AxiosPromise<UserDelegatedAccess> {
            return UserApiFp(configuration).addAccountDelegate(userId, userDelegatedAccessCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new collection for a user
         * @summary Add a new collection
         * @param {string} userId ID of user to create the collection for
         * @param {CollectionCreate} collectionCreate Create a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: any): AxiosPromise<Collection> {
            return UserApiFp(configuration).addUserCollection(userId, collectionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document for a user
         * @summary Add a new document
         * @param {string} userId ID of user to create document for
         * @param {DocumentCreate} documentCreate Create a new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any): AxiosPromise<Document> {
            return UserApiFp(configuration).addUserDocument(userId, documentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user details
         * @summary Get user
         * @param {string} userId ID of user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List audit activity in an account, limited to 50 most recent items.
         * @summary List activity for an account
         * @param {string} userId ID of user to find collections for
         * @param {string} [nextToken] The token to be used to fetch the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivity(userId: string, nextToken?: string, options?: any): AxiosPromise<ActivityList> {
            return UserApiFp(configuration).listAccountActivity(userId, nextToken, options).then((request) => request(axios, basePath));
        },
        /**
         * List access delegated to and from a user
         * @summary List delegated access
         * @param {string} userId ID of user to find delegated access items for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountDelegates(userId: string, options?: any): AxiosPromise<UserDelegatedAccessList> {
            return UserApiFp(configuration).listAccountDelegates(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections owned by a user
         * @summary List collections owned by a user
         * @param {string} userId ID of user to find collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections(userId: string, search?: string, options?: any): AxiosPromise<CollectionList> {
            return UserApiFp(configuration).listUserCollections(userId, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections shared to user
         * @summary List collections shared to user
         * @param {string} userId ID of user to find accessible collections for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollectionsShared(userId: string, search?: string, options?: any): AxiosPromise<SharedCollectionList> {
            return UserApiFp(configuration).listUserCollectionsShared(userId, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List documents owned by a user
         * @summary List documents owned by a user
         * @param {string} userId ID of user to find documents for
         * @param {string} [search] Search string to narrow down list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDocuments(userId: string, search?: string, options?: any): AxiosPromise<DocumentList> {
            return UserApiFp(configuration).listUserDocuments(userId, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Accept application Terms of Use for a user
     * @summary Accept Terms
     * @param {string} userId ID of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public acceptTerms(userId: string, options?: any) {
        return UserApiFp(this.configuration).acceptTerms(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add delegated access to a user for current user
     * @summary Add delegated access
     * @param {string} userId ID of user to delegate access for
     * @param {UserDelegatedAccessCreate} userDelegatedAccessCreate Create a new delegated access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addAccountDelegate(userId: string, userDelegatedAccessCreate: UserDelegatedAccessCreate, options?: any) {
        return UserApiFp(this.configuration).addAccountDelegate(userId, userDelegatedAccessCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new collection for a user
     * @summary Add a new collection
     * @param {string} userId ID of user to create the collection for
     * @param {CollectionCreate} collectionCreate Create a new collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserCollection(userId: string, collectionCreate: CollectionCreate, options?: any) {
        return UserApiFp(this.configuration).addUserCollection(userId, collectionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document for a user
     * @summary Add a new document
     * @param {string} userId ID of user to create document for
     * @param {DocumentCreate} documentCreate Create a new document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserDocument(userId: string, documentCreate: DocumentCreate, options?: any) {
        return UserApiFp(this.configuration).addUserDocument(userId, documentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user details
     * @summary Get user
     * @param {string} userId ID of user to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List audit activity in an account, limited to 50 most recent items.
     * @summary List activity for an account
     * @param {string} userId ID of user to find collections for
     * @param {string} [nextToken] The token to be used to fetch the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listAccountActivity(userId: string, nextToken?: string, options?: any) {
        return UserApiFp(this.configuration).listAccountActivity(userId, nextToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List access delegated to and from a user
     * @summary List delegated access
     * @param {string} userId ID of user to find delegated access items for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listAccountDelegates(userId: string, options?: any) {
        return UserApiFp(this.configuration).listAccountDelegates(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List collections owned by a user
     * @summary List collections owned by a user
     * @param {string} userId ID of user to find collections for
     * @param {string} [search] Search string to narrow down list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserCollections(userId: string, search?: string, options?: any) {
        return UserApiFp(this.configuration).listUserCollections(userId, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List collections shared to user
     * @summary List collections shared to user
     * @param {string} userId ID of user to find accessible collections for
     * @param {string} [search] Search string to narrow down list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserCollectionsShared(userId: string, search?: string, options?: any) {
        return UserApiFp(this.configuration).listUserCollectionsShared(userId, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List documents owned by a user
     * @summary List documents owned by a user
     * @param {string} userId ID of user to find documents for
     * @param {string} [search] Search string to narrow down list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDocuments(userId: string, search?: string, options?: any) {
        return UserApiFp(this.configuration).listUserDocuments(userId, search, options).then((request) => request(this.axios, this.basePath));
    }
}


