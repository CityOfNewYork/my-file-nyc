<template>
  <v-skeleton-loader v-if="loading" type="image"></v-skeleton-loader>
  <div v-else-if="isInfected">
    File is infected and should not be downloaded
  </div>
  <iframe
    v-else-if="isPdf"
    :src="url"
    :title="`${$t('document.previewOf')} ${document.name}`"
    type="application/pdf"
    class="pdf viewer"
  >
    <p>PDF document: {{ document.name }}</p>
  </iframe>
  <div v-else class="text-center image viewer">
    <v-dialog v-model="dialog">
      <template v-slot:activator="{ on, attrs }">
        <img
          v-bind="attrs"
          v-on="on"
          :style="$vuetify.breakpoint.smAndUp && 'width: 50%'"
          :src="url"
          :alt="`${documentName} (${fileName})`"
        />
      </template>
      <v-card>
        <div class="text-center image viewer">
          <v-card-title class="d-block text-h5">
            {{ $t(document.name) }}
          </v-card-title>
          <img :src="url" :alt="`${documentName} (${fileName})`" />
          <v-card-actions class="d-block">
            <v-btn class="text-center" text @click="dialog = false">
              Close Document
            </v-btn>
          </v-card-actions>
        </div>
      </v-card>
    </v-dialog>
  </div>
</template>

<script lang="ts">
import {
  Document,
  FileContentTypeEnum,
  DocumentFile as DocumentFileType,
  FileDownloadDispositionTypeEnum,
} from 'api-client'
import { Vue, Component, Prop } from 'nuxt-property-decorator'

@Component
export default class DocumentFile extends Vue {
  @Prop({ required: true }) document: Document
  @Prop({ required: true }) file: DocumentFileType

  url = ''
  loading = true
  dialog = false

  async mounted() {
    this.url = await this.$store.dispatch('document/downloadFile', {
      document: this.document,
      file: this.file,
      disposition: FileDownloadDispositionTypeEnum.Inline,
    })
    console.log(this.document)
    if (this.isTiff) {
      await this.processTif()
    }

    this.loading = false
  }

  get fileName() {
    return this.file.name
  }

  get documentName() {
    return this.document.name
  }

  get isTiff() {
    return this.file.contentType === FileContentTypeEnum.ImageTiff
  }

  get isInfected() {
    return this.file.scanStatus === 'infected'
  }

  get isPdf() {
    return this.file.contentType === FileContentTypeEnum.ApplicationPdf
  }

  async processTif() {
    if (!this.url.includes('.tiff') && !this.url.includes('.tif')) return

    const UTIF = await import('utif')
    const req = await fetch(this.url)
    const buff = await req.arrayBuffer()
    const ifds = UTIF.decode(buff)
    let vsns = ifds
    let ma = 0
    let page = vsns[0]
    if (ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD as any[])
    for (let i = 0; i < vsns.length; i++) {
      const img = vsns[i]
      if (img.t258 == null || (img.t258 as Array<string | number>).length < 3)
        continue
      const ar = (img.t256 as number) * (img.t257 as number)
      if (ar > ma) {
        ma = ar
        page = img
      }
    }
    UTIF.decodeImage(buff, page, ifds)
    const rgba = UTIF.toRGBA8(page)
    const w = page.width
    const h = page.height
    const cnv = document.createElement('canvas')
    cnv.width = w
    cnv.height = h
    const ctx = cnv.getContext('2d') as CanvasRenderingContext2D
    const imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h)
    ctx.putImageData(imgd, 0, 0)
    this.url = cnv.toDataURL()
  }
}
</script>

<style scoped lang="scss">
.viewer {
  &.pdf {
    width: 100%;
    height: calc(100vh - 10.5rem);
  }
  &.image {
    img {
      max-width: 90%;
      object-fit: contain;
      border-radius: 0.5rem;
    }
  }
}
</style>
